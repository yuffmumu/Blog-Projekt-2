# Blog 2 Stundenübersicht

[Projektfindungsphase 8.12.2020-11.12.2020](#1)   

[Projektfindungsphase 11.12.2020-27.1.2021](#2)

[Erste Programmierversuche 22.2.2021](#3)

[Wiederbeginn des Präsenzunterricht 4.3.2021](#4) 

[Erste Erfolge beim Strukturieren vom Programm 11.3.2021](#5)  

[Der fast perfekte Sprung 12.3.2021](#6)  

[Der perfekte Sprung 11.3.2021](#7) 

[Tetris 18-25.3.2021](#8) 

[Respawn 25.3-14.4.2021](#9) 

[Delete Row 15-16.4.2021](#10)


### <a name="1"></a>Projektfindungsphase 8.12.2020-11.12-2020:
Wir begannen die Suche nach einer neuen Plattform für unser 2. Projekt.
Da wir die Möglichkeiten von "Snap!" im ersten Projekt relativ vollständig ausgereizt hatten war klar das wir eine neue, komplexere Plattform, welche aber natürlich auch mehr Möglichkeiten mit sich bringen würde, suchen mussten.
Ziehmlich direkt standen 2 Möglichkeiten im Raum: Um Zugang zum textbasierten Programmieren zu finden bot sich "Greenfoot" an da es eine reine Lehrumgebung ist. 
Die andere Möglichkeit war ein Projekt auf Basis der "Unreal Engine". Dies war den Potential des letztendlichen Produktes entsprechend extrem Reizvoll, jedoch aber auch entsprechend kompliziert.
Wir nahmen also Projekte von anderen mit der engine in Augenschein und recherchierten um ein Gefühl dafür zu bekommen, inwiefern ein erfolgreiches Projekt, insbesondere in Anbetracht unserer bisherigen Fähigkeiten, realisierbar wäre.
Die Möglichkeit in der "unreal engine" sowohl mit Programmieren im Textformat, als auch mit den "blueprints" der engine zu arbeiten, überzeugte uns vorerst. 
Wir behielten uns aber dennoch vor nicht spätestens nach den Weinachtsferien doch noch zu einem Greenfoot Projekt zu wechseln, würden wir feststellen, dass ein Projekt mit der "unreal engine" außerhalb unserer Möglichkeiten stünde.

Wir begannen also mit der Recherche, um einen Zugang zur "unreal engine" zu finden".

### <a name="2"></a>Projektfindungsphase 11.12.2020-27.01.2021:
Wir beschäftigten uns für etwas mehr als einen Monat mit Unreal Engine um ein Gefühl dafür zu bekommen, ob Unreal Engine im Rahmen unserer Möglichkeiten, also neben dem Abitur etc., liegt. 
Im Verlauf unserer Recherchen stellten wir fest, dass das Arbeiten mit der Unreal Engine zwar durchaus möglich ist, sich aber unseres Wissensstandes wegen vor allem auf die Möglichkeiten der "blueprints" beschränken würde, was ja wie aus den Rücksprachen mit ihnen hervorging, nicht ganz das eigentlich zu verfolgende Ziel ist.
Dementsprechend entschieden wir uns, nachdem wir entschieden hatten, dass die investierbare Zeit in das Projekt nicht ausreichen würde um die Unreal Engine auf eine entsprechende Weise zu betreiben ein Greenfoot-Projekt zu machen.

Bei Greenfoot selbst stellten wir daraufhin die ersten Überlegungen zur Entwicklung des Projektes an.
Um, wie auch im ersten Projekt einen Wiederspielwert zu gewährleisten, was uns wichtig ist, werden wir vermutlich versuchen eine art "Randomizer" zu integrieren, welches das Spiel auf irgendeine Weise zufällig beeinflusst z.B. dass die Struktur der Spielwelt zufällig ist und somit intersessant bleibt.
Auf welche Weise wir dies genau erreichen ist bis hier hin noch nicht klar, da Vergleichbare Spiele, welche über einen "seed" die Spielwelt beeinflussen eventuell zu umfangreich bzw. die Funktionsweise für unsere Zwecke suboptimal ist.

### <a name="3"></a>22.02.2021:
Wir haben uns ihren Ratschlag, uns "the joy of code" anzugucken zu herzen genommen und uns einen Ersten Eindruck von der Struktur Greenfoots geschaffen, sowie versucht nachzuvollziehen inwiefern sich "Greenfoot" mit "Snap" vergleichen lässt. Wir haben uns unter anderem mit dem Prinziep der Klassen und Objekte auseinander gesetzt.

### <a name="4"></a>4.03.2021:
Zunächst, da der Präsenzunterricht wieder angefangen hatte haben wir dann versucht tatsächlich in "Greenfoot" zu arbeiten.
Um einen Zugang zu finden versuchten wir Grundstrukturen, wie wir sie in "Snap!" bei unserem ersten Projekt hatten, nun in Java umzusetzen.
Selbstverständlich hatten wir in Errinerung an die Snapblöcke eine Vorstellung dessen, was es zu Programmieren galt (z.B. einen "if" command für die Fortbewegung), jedoch bereitete uns die offensichtlich sehr viel komplexer wirkende und grundsätzlich andere Struktur des textbasierten Programmierens sofort Probleme.
Nach Hilfe von Herrn Buhl und Recherche schafften wir es jetztendlich doch, erste "actors" in der Welt zu definieren und die grundlegendsten Bewegungen auf Befehl umzusetzen. 

### <a name="5"></a>Erste Erfolge beim Strukturieren vom Programm 11.03.2021:
Unser Konzept und unsere Ambitionen ein verhältnissmäßig komplexes und umfangreiches Spiel zu programmieren, mussten wir, der Komplexität des Programmierens und insbesondere der im Ramen des 2. Halbjahrs sehr begrenzten Zeit wegen, vorerst zur Seite legen um uns auf das Programmieren in Greenfoot auf einer grundlegenden Ebene zu konzentrieren.
Wir wanden uns also vorerst dem Lernen der Basics zu, um von Grund auf ein sinnvolles Programm zu entwickeln, dass die grundlegenden und sinnvollen Strukturen des Programmierens beinhaltet.
Alle Methoden sollten gut strukturiert und modular eingearbeitet werden.
Hier gab es auch erste Erfolge insofern, als das wir verstanden, wie wir verschiedene Methoden unterteilen konnten um eine übersichtliche Struktur zu erreichen. 

![image](https://user-images.githubusercontent.com/69623479/111297605-16061300-864e-11eb-9497-29a0fcb88fb8.png)

Wir entschieden uns daraufhin dafür zu versuchen, unseren "Sprung" aus dem 1. Projekt in unseren Greenfoot projekt zu reproduzieren, da in demselben sehr viele hilfreiche und nützliche Commands stecken und wir uns erhofften, auf diesem Wege parrallelen zwischen den beiden Programmiermöglichkeiten zu schaffen und so über einen praktischen Ansatz, uns in Greenfoot zurecht zu finden.
Wir konnte dadurch bis hierhin nun Variablen definieren und einsetzen, forever Schleifen umsetzen und einen boolean für das Berühren des Bodens schaffen.
Was bis hierhinm, der Zeit wegen, noch nicht möglich war, war die Variable immer wieder zu verändern, bis der Character wieder den Boden berührt, wie wir es in Snap mir einem "repeat until" block gemachten hatten.

### <a name="6"></a>Der fast perfekte Sprung 12.03.2021:

Die Variable progressiv zu ändern war nun Ziel für die Stunde.
Da dies auch nachdem wir die nicht funktonierende "while" schleife aufgelöst hatten und die commands entsprechend neu angeordnet hatten, noch nicht funktionierte lernten wir die Methode mit den "breaking points" kennen.
Wir untersuchten die einzelnen Schritte unserer commands und fanden heraus, dass wir die Änderung der Variable zwar richtig programmiert hatten, dieser Schritt jedoch nie erreicht wurde. 

![image](https://user-images.githubusercontent.com/69623479/111297263-b7d93000-864d-11eb-9314-70c9ca476c20.png)

Woran das genau lag konnten wir noch nicht lösen.
Dennoch ließ sich bis hierhin festhalten, dass wir unsere Grundprinzipien aus Snap wie "if commands" oder Variablen in Java anwenden konnten.


### <a name="7"></a>Der perfekte Sprung 16.03.2021:

Wir wanden uns nun dem letzten Problem des Sprungs zu. 
Wir lagen richtig, dass prinzipiel beim Sprung kein Fehler war.
Das einzige Problem war, dass eine "if schleife" in der vorigen drin steckte sodass die Variablen sich wiedersprachen. Außerdem musste es "jump_velocity -1" anstelle von "jump_velocity +1" heißen.
Dies war schnell behoben und der Sprung funtkionierte genau so dynamisch und schön wie in unserem Snap Projekt.
Der finale Code für den Sprung und die Bewegung nach links und rechts sah nun so aus:

![image](https://user-images.githubusercontent.com/69623479/111298393-fae7d300-864e-11eb-8b1e-aa69dcc17fb4.png)


### <a name="8"></a>Tetris 18-25.03.2021:

Es wurde nun Zeit uns für ein Projekt zu entscheiden, dass im Ramen der Zeit erreichbar, mit unseren Fähigkeiten machbar und unserem Wunsch ein richtiges Spiel entsprechend ist.
Schnell stand die Idee im Raum ein altes Arcade Spiel zu reproduzieren.
Wichtig bei der Entscheidung welches war, dass wir uns von vornerein die Strukturen des Programms in Sachen Klassen und Design vorstellen konnten und die Komplexität des Spiels anspruchsvoll genug um Spaß am Ergebniss haben zu können, aber nicht zu anspruchsvoll für den sehr begrenzten Zeitraum.
Mit diesen Kriterien konnten wir einige Kandidaten (z.B. Pacman) auschließen.
Wir entschieden uns nach kurzer Recherche für Tetris.
Der Zeit wegen war es jedoch unrealisitsch das Spiel in vollem Ausmaß zu programmieren, da allein die verschiedenen Formen im spiel zu Integrieren sehr aufwendig gewesen wäre, da die Formen in Greenfoot zu erstellen eben nur wie auf einer Leinwand funktioniert, sodass wir bei manchen Formen Berührungspunkte an stellen hätten, die garnicht eingezeichnet wären.
Dementsprechend einigten wir uns das Spiel nur im Ramen des grundlegenden Konzepts zu programmieren, sodass wir uns die aufwendigeren Formen und andere Details die zwar den Spielfluss interessanter machen würden, aber keine Prinzipielle änderung am Programm bedeuten, wie das Beschleunigen der Fallzeit der Teile über Zeit, sparen konnten.

-------Visualisierung von leinwand und berührungspunkten wo wir nichts eingezeichnet haben

Was wir bereits schafften war über eine Modulu Funktion den Block immer wieder ein Stück nach unten bewegen zu lassen indem wir sagten, dass jedes mal wenn der Rest den Wert 30 erreicht, der Block einen bestimmten Wert nach unten gehen soll. Auch grundlegend den Block währende er sich nach unten bewegte, nach links und rechts zu bewegen war kein weiteres Problem, da wir dies ja bereits in unserer Testphase gelernt hatten.

Der Code für die aktive (links und rechts) und permanente (modulu basierte) Bewegung sah dann so aus:

![image](https://user-images.githubusercontent.com/69623479/112623109-38591700-8e2c-11eb-9f85-18b83ab754d4.png)


### <a name="9"></a>Respawn 25.3-16.4.2021:
Unser nächstes Ziel war es, dass wenn das "L_Teil" den Boden, bzw. in unserem Fall den "bottom_detector" berüht, ein neues "L_Teil" gespawnt wird. Bis jetzt wurde es nur zu Anfang im world constructor gespawnt. Also erstellten wir den boolean "detect", der immer dann true wurde, wenn das "L_Teil" den "bottom_detector" berührte. Sobald die Variable "detect" "true" wurde, sollte mithilfe einer if_Schleife ein neues "L_Teil" gespawnt werden (Wenn die Bedingung detect == true erfüllt wurde, führe die Methode addObject(new L_Teil, 8, 0) aus). Es kam jedoch immer der Fehler "cannot find symbol - method addObject(L_Teil, int, int)" raus. Daraus schlossen wir, dass man nur in der World Klasse Objekte erzeugen kann. Also kopierten wir unsere if-Schleife in die MyWorld Klasse. Doch wieder kam eine Fehlermeldung. Dieses mal hieß es: "cannot find symbol - variable detect". Das hieß offensichtlich, dass die Variable "detect" nicht von sowohl der "world", als auch dem actor "L_Teil" genutzt werden konnte.
Von Snap waren wir es gewöhnt, dass alle Objekte standartmäßig auf alle Variablen zugreifen konnten, dementsprechend waren wir unschlüssig, was zu tun war. Nach langer Recherche und einigen missglückten Versuchen, (vllt. versch. Lös. Ansätze erläutern) stießen wir schließlich auf eine Seite, die erklärte, dass man Objekte innnerhalb einer Actor Klasse erzeugen kann, indem man sich Methoden aus anderen Klassen holt. Dies funktioniert mit der sogenannten Punkt-Notation. Wir brauchten eine Methode der World Klasse. Also schrieben wir getWorld() vor die addObject Methode. Als wir es dann ausprobierten funktionierte alles. Die Variable detect, und die if-Schleife in der MyWorld Klasse wurden obsolet, da wir ja direkt in der Actor Klasse neue Objekte erzeugen konnten. Der eigentlich simple code sah dann final wie folgt aus:


![programm screenshot](https://user-images.githubusercontent.com/69623479/114703384-82476580-9d25-11eb-9efd-0c9d62ba4489.PNG)

### <a name="10"></a>Delete Row 25.3-16.4.2021:
Wie man es von Tetris kennt, sollte jede volle Reihe entfernt werden. D.h wir mussten irgendwie überprüfen, ob, in unserem Fall, alle 5 Blöcke unten angekommen sind und diese dann mittels der removeObject() Methode aus der World Klasse entfernen. Wir entfernten den einzelnen bottom_detector und erzeugten 5 "sublclasses" des bottom_detectors (bottom_detector1, bottom_detector2 usw.). Wir platzierten sie so in der Welt, dass alle 5 möglichen x-Koordinaten des L_Teils abgedeckt waren. In jedem bottom_detector wurde ein static boolean namens "touches" definiert, der dann true wurde, wenn ein "L_Teil" ihn berührt. Dadurch, dass es ein static boolean war, konnte der (Main-)bottom_detector mit der Punkt-Notation und dem entsprechenden Klassennamen auf alle "touches"-Variablen zugreifen. Der (Main-)bottom_detector prüft nun in einer if-Schleife ob alle "touches"-Variablen true sind; war dies der Fall, konnte das programm von daher sozusagen erkennen, dass die Reihe voll war und die Variable "delete_row" auf true setzen. Was uns an diesem Punkt verwirrt hat, war, dass delete_row nie auf true gesetzt wurde. Dies konnten wir mithilfe eines Breakpoints ermitteln. Nach einigen Überlegungen fiel uns auf, dass wir die Überklasse "bottom_detector" zwar definiert, aber nicht zur Welt hinzugefügt hatten. Als wir dies behoben, funktionierte es. Daraus schlossen wir, dass die Actors erstmal in der Welt existieren müssen, um Einfluss auf Variablen etc. zu nehmen. Im L_Teil wurde dann die if-Schleife, die überprüft ob "delete_row" true ist, ausgelöst. Sie sollte nun die 5 "L_Teile" (Blöcke) entfernen, die die unterste Reihe füllten. In der Greenfoot Class Documenentaion unter World fanden wir die removeObject() und die remove Objects() Methoden. Beides hat uns jedoch erst nicht geholfen, da man keine Klassen sondern nur Objekte als Parameter angeben konnte. So fanden wir im Internet eine Version mit "removeObject(this)". Jedoch wurde dadurch nur ein "L_Teil"/Block und nicht alle 5 entfernt. Nach weiterer Recherche stießen wir auf die Methode getWolrd().removeObjects(getWolrd().getObjects(-classname-)), mit der man gleich alle Objekte einer Klasse entfernen konnte.
Dies funktionierte auch, nun konnte man aber nicht mehr weiter spielen, da auch der nächste Block, der gerespawnt ist und somit noch oben war, entfernt wurde.
Um die "L_Teile" weiter zu differenzieren wollten wir sie über eine Liste aufteilen. Sobald ein ein L_Teil einen "bottom_detector" berührt sollte es zu dieser Liste hinzugefügt werden, um diese Liste dann, sofern sie weitere Bedingungen erfüllt an denen sich erkennen lässt, dass die Reihe unten voll sein muss, wie i<5 (für die 5 positionen, die der Block auf der x-Achse einnehmen kann) oder "bottom_detector.delete_row == true" (dafür, das alle bottom_detecors belegt sind), zu löschen.

![image](https://user-images.githubusercontent.com/69623479/115032839-0f2b2400-9eca-11eb-9526-6bb8f3483251.png)

Dieser code funktionierte jedoch noch nicht vollständig und konnte im Zeitramen nicht mehr vollständig gelöst werden.
